/* 1. Package e importaciones */
package Language;
import java.util.ArrayList;
import java_cup.runtime.*;
import Colors.Token;
import Colors.Type;
import Components.ErrorS;
import Components.Instruction;
import Controller.Expression;
import Controller.Regex;
import Controller.Set;

/* 2. Codigo para el parser, variables y metodos */

parser code 
{:
    Scanner s;
    public Parser(Scanner s) {
        super(s);
        this.s = s;
    }

    ArrayList<Instruction> flowExe = new ArrayList<>();
    ArrayList<Instruction> errors = new ArrayList<>();
    ArrayList<Expression> expressions = new ArrayList<>();
    ArrayList<Regex> regexs = new ArrayList<>();
    ArrayList<Set> sets = new ArrayList<>();
    Expression expression = new Expression();
    Regex regex = new Regex();
    Set set = new Set();
    public void syntax_error(Symbol sym) {
        errors.add(
            new Instruction(
                new ErrorS(
                    sym.left,
                    sym.right,
                    sym.value,
                    Sym.terminalNames[sym.sym]
                )
            )
        );
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        errors.add(
            new Instruction("Unrecovered Syntax Error.")
        );
    }
    public ArrayList<Instruction> getExcecution() {
        return flowExe;
    }
    public String getStrExecution() {
        String exe = "";
        for(int i = 0; i < flowExe.size(); i ++) {
            exe += flowExe.get(i) + "\n";
        }
        if(errors.size() > 0) {
            for(int i = 0; i < errors.size(); i ++) {
                exe += errors.get(i) + "\n";
            }
            return exe + "\n";
        }
        return exe + "SUCCESSFULLY RUN";
    }
    public String getStrErrors() {
        String exe = "";
        for(int i = 0; i < errors.size(); i ++) {
            exe += "-> " + errors.get(i) + "\n";
        }
        return exe + "\n";
    }
    public boolean isSuccessExecution() {
        if(errors.size() > 0) {
            return false;
        }
        return true;
    }
    private void addRange(String start,String end) {
        set.startChar = start.charAt(0);
        set.endChar = end.charAt(0);
    }
    private void addSpecific(String ch) {
        set.specifics.add(ch.charAt(0));
    }
    private void addSet(String id) {
        set.id = id;
        sets.add(set);
        flowExe.add(new Instruction(set));
        set = new Set();
    }
    public ArrayList<Set> getSets() {
        return sets;
    }
    public String getStrSets() {
        String str = "";
        for(Set set : sets) {
            str += set + "\n";
        }
        return str;
    }
    private void addElement(String element,Type type) {
        regex.expression.push(new Token(element,type));
    }
    private void addRegex(String id) {
        regex.id = id;
        regexs.add(regex);
        regex.expression.add(0,new Token(".",Type.CONCAT));
        regex.expression.push(new Token("#",Type.CONCAT));
        flowExe.add(new Instruction(regex));
        regex = new Regex();
    }
    public ArrayList<Regex> getRegexs() {
        return regexs;
    }
    public String getStrRegexs() {
        String str = "";
        for(Regex regex : regexs) {
            str += regex + "\n";
        }
        return str;
    }
    private void addExpression(String id,String string) {
        expression.id = id;
        expression.string = string;
        expressions.add(expression);
        flowExe.add(new Instruction(expression));
        expression = new Expression();
    }
:} 

/* 3. Terminales*/

terminal String RW_CONJ, ID, STRING, CHAR, CHARNUM;
terminal String LBRACKET, RBRACKET;
terminal String SEMICOLON, COLON, COMMA, PROMPT, TILDE;
terminal String OR, POSITIVE, KLEENE, CONCAT, OPTIONAL;
terminal String LIMIT, SINGLEQUOTE, DOUBLEQUOTE, ENTER;

/* 4. No Terminales*/
non terminal ini, body, declarations, evaluations;
non terminal instructions,instruction;
non terminal set, elements;
non terminal specific, regex;
non terminal operations, operation;
non terminal node;
non terminal analysis, expression;
non terminal String character;
non terminal String ids;

/* 5. Precedencias */

/* 6. Gramatica Libre de Contexto */

start with ini;

ini::=LBRACKET body RBRACKET | /*empty*/;

body::=instructions declarations | /*empty*/;

declarations::=LIMIT evaluations | /*empty*/;

evaluations::=analysis | /*empty*/;

instructions::=
    instruction error instructions |
    instruction instructions |
    instruction error |
    instruction;

instruction::=
    set |
    regex;

set::=RW_CONJ COLON ids:id PROMPT elements SEMICOLON {:addSet(id);:};

elements::=
    character:start TILDE character:end {:addRange(start,end);:}|
    specific;

specific::=
    character:ch {:addSpecific(ch);:} COMMA specific |
    character:ch {:addSpecific(ch);:};

character::=
    CHAR:ch         {:RESULT = ch;:} |
    CHARNUM:ch      {:RESULT = ch;:} |
    LBRACKET:lb     {:RESULT = lb;:} |
    RBRACKET:rb     {:RESULT = rb;:} |
    SEMICOLON:sm    {:RESULT = sm;:} |
    COLON:cn        {:RESULT = cn;:} |
    COMMA:cm        {:RESULT = cm;:} |
    OR:or           {:RESULT = or;:} |
    POSITIVE:pl     {:RESULT = pl;:} |
    KLEENE:kl       {:RESULT = kl;:} |
    OPTIONAL:op     {:RESULT = op;:} |
    CONCAT:cc       {:RESULT = cc;:};

regex::=ids:id PROMPT operations SEMICOLON {:addRegex(id);:};

operations::=
    operations operation |
    operation;

operation::=
    CONCAT:cc   {:addElement(cc,Type.CONCAT);:} operation operation |
    OR:or       {:addElement(or,Type.OR);:} operation operation |
    KLEENE:kl   {:addElement(kl,Type.KLEENE);:} operation |
    OPTIONAL:op {:addElement(op,Type.OPTIONAL);:} operation |
    POSITIVE:pl {:addElement(pl,Type.POSITIVE);:} operation |
    node;

node::=
    LBRACKET ids:id RBRACKET {:addElement(id,Type.ID);:} |
    STRING:str               {:if(str.equals("\"\"")) {syntax_error(((java_cup.runtime.Symbol) CUP$Parser$stack.peek()));return ((java_cup.runtime.Symbol) CUP$Parser$stack.peek());}addElement(str,Type.STRING);:} |
    ENTER:enter              {:addElement(enter,Type.ENTER);:} |
    DOUBLEQUOTE:dq           {:addElement(dq,Type.DOUBLEQUOTE);:} |
    SINGLEQUOTE:sq           {:addElement(sq,Type.SINGLEQUOTE);:};

analysis::=
    expression error analysis |
    expression analysis |
    expression error |
    expression;

expression::=ids:id COLON STRING:str SEMICOLON {:addExpression(id,str);:};

ids::= ID:id {:RESULT = id;:} | CHAR:ch {:RESULT = ch;:};