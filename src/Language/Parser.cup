/* 1. Package e importaciones */
package Language;
import java.util.ArrayList;
import java_cup.runtime.*;
import Colors.Token;
import Colors.Type;
import Components.ErrorS;
import Components.Instruction;
import Controller.Expression;
import Controller.Regex;
import Controller.Set;

/* 2. Codigo para el parser, variables y metodos */

parser code 
{:
    Scanner s;
    public Parser(Scanner s) {
        super(s);
        this.s = s;
    }

    ArrayList<Instruction> flowExe = new ArrayList<>();
    ArrayList<Instruction> errors = new ArrayList<>();
    ArrayList<Expression> expressions = new ArrayList<>();
    ArrayList<Regex> regexs = new ArrayList<>();
    ArrayList<Set> sets = new ArrayList<>();
    Expression expression = new Expression();
    Regex regex = new Regex();
    Set set = new Set();
    public void syntax_error(Symbol sym) {
        errors.add(
            new Instruction(
                new ErrorS(
                    sym.left,
                    sym.right,
                    sym.value
                )
            )
        );
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        errors.add(
            new Instruction("Unrecovered Syntax Error.")
        );
    }
    public ArrayList<Instruction> getExcecution() {
        return flowExe;
    }
    public String getStrExecution() {
        String exe = "";
        for(int i = 0; i < flowExe.size(); i ++) {
            exe += flowExe.get(i) + "\n";
        }
        if(errors.size() > 0) {
            for(int i = 0; i < errors.size(); i ++) {
                exe += errors.get(i) + "\n";
            }
            return exe + "\n";
        }
        return exe + "SUCCESSFULLY RUN";
    }
    private void addRange(String start,String end) {
        set.startChar = start;
        set.endChar = end;
    }
    private void addSpecific(String ch) {
        set.specifics.add(ch);
    }
    private void addSet(String id) {
        set.id = id;
        sets.add(set);
        flowExe.add(new Instruction(set));
        set = new Set();
    }
    public ArrayList<Set> getSets() {
        return sets;
    }
    public String getStrSets() {
        String str = "";
        for(Set set : sets) {
            str += set + "\n";
        }
        return str;
    }
    private void addElement(String element,Type type) {
        regex.expression.push(new Token(element,type));
    }
    private void addRegex(String id) {
        regex.id = id;
        regexs.add(regex);
        regex.expression.add(0,new Token(".",Type.CONCAT));
        regex.expression.push(new Token("#",Type.CONCAT));
        flowExe.add(new Instruction(regex));
        regex = new Regex();
    }
    public ArrayList<Regex> getRegexs() {
        return regexs;
    }
    public String getStrRegexs() {
        String str = "";
        for(Regex regex : regexs) {
            str += regex + "\n";
        }
        return str;
    }
    private void addExpression(String id,String string) {
        expression.id = id;
        expression.string = string;
        expressions.add(expression);
        flowExe.add(new Instruction(expression));
        expression = new Expression();
    }
:} 

/* 3. Terminales*/

terminal String RW_CONJ, ID, STRING, CHAR;
terminal String LBRACKET, RBRACKET;
terminal String SEMICOLON, COLON, COMMA, PROMPT, TILDE;
terminal String OR, POSITIVE, KLEENE, CONCAT;
terminal String LIMIT;

/* 4. No Terminales*/
non terminal ini;
non terminal instructions,instruction;
non terminal set, elements;
non terminal specific, regex;
non terminal operations, operation;
non terminal node;
non terminal analysis, expression;
non terminal String character;
non terminal String ids;

/* 5. Precedencias */

/* 6. Gramatica Libre de Contexto */

start with ini;

ini::=LBRACKET instructions LIMIT analysis RBRACKET;

instructions::=
    instruction error instructions |
    instruction instructions |
    instruction error |
    instruction;

instruction::=
    set |
    regex;

set::=RW_CONJ COLON ids:id PROMPT elements SEMICOLON {:addSet(id);:};

elements::=
    character:start TILDE character:end {:addRange(start,end);:}|
    specific;

specific::=
    character:ch {:addSpecific(ch);:} COMMA specific |
    character:ch {:addSpecific(ch);:};

character::=
    CHAR:ch         {:RESULT = ch;:} |
    LBRACKET:lb     {:RESULT = lb;:} |
    RBRACKET:rb     {:RESULT = rb;:} |
    SEMICOLON:sm    {:RESULT = sm;:} |
    COLON:cn        {:RESULT = cn;:} |
    COMMA:cm        {:RESULT = cm;:} |
    OR:or           {:RESULT = or;:} |
    POSITIVE:pl     {:RESULT = pl;:} |
    KLEENE:kl       {:RESULT = kl;:} |
    CONCAT:cc       {:RESULT = cc;:};

regex::=ids:id PROMPT operations SEMICOLON {:addRegex(id);:};

operations::=
    operations operation |
    operation;

operation::=
    CONCAT:cc   {:addElement(cc,Type.CONCAT);:} operation operation |
    OR:or       {:addElement(or,Type.OR);:} operation operation |
    KLEENE:kl   {:addElement(kl,Type.KLEENE);:} operation |
    POSITIVE:pl {:addElement(pl,Type.POSITIVE);:} operation |
    node;

node::=
    LBRACKET ids:id RBRACKET {:addElement(id,Type.ID);:} |
    STRING:str               {:addElement(str,Type.STRING);:};

analysis::=
    expression error analysis |
    expression analysis |
    expression error |
    expression;

expression::=ids:id COLON STRING:str SEMICOLON {:addExpression(id,str);:};

ids::= ID:id {:RESULT = id;:} | CHAR:ch {:RESULT = ch;:};