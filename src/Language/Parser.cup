/* 1. Package e importaciones */
package Language;
import java.util.ArrayList;
import java_cup.runtime.*;
import Components.ErrorS;
import Components.Instruction;
import BackEnd.Set;
import BackEnd.Regex;

/* 2. Codigo para el parser, variables y metodos */

parser code 
{:
    Scanner s;
    public Parser(Scanner s) {
        super(s);
        this.s = s;
    }

    //ArrayList<Instruction> flowExe = new ArrayList<>();
    ArrayList<Instruction> errors = new ArrayList<>();
    ArrayList<Set> sets = new ArrayList<>();
    ArrayList<Regex> regexs = new ArrayList<>();
    Set set;
    Regex regex;
    public void syntax_error(Symbol sym) {
        errors.add(
            new Instruction(
                new ErrorS(
                    sym.left,
                    sym.right,
                    sym.value
                )
            )
        );
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        errors.add(
            new Instruction("Unrecovered Syntax Error.")
        );
    }
    public String getExecution() {
        String exe = "";
        /*for(int i = 0; i < flowExe.size(); i ++) {
            exe += flowExe.get(i) + "\n";
        }*/
        for(int i = 0; i < errors.size(); i ++) {
            exe += errors.get(i) + "\n";
        }
        return exe + "\n";
    }
    private void initSet(String id) {
        set = new Set();
        set.id = id;
    }
    private void addRange(String start,String end) {
        set.startChar = start;
        set.endChar = end;
    }
    private void addSpecific(String ch) {
        set.specifics.add(ch);
    }
    private void addSet() {
        sets.add(set);
        set = null;
    }
    public ArrayList<Set> getSets() {
        return sets;
    }
    public String getStrSets() {
        String str = "";
        for(Set set : sets) {
            str += set + "\n";
        }
        return str;
    }
    private void initRegex(String id) {
        regex = new Regex();
        regex.id = id;
    }
    private void addElement(String element) {
        regex.expression.push(element);
    }
    private void addRegex() {
        regexs.add(regex);
        regex = null;
    }
    public ArrayList<Regex> getRegexs() {
        return regexs;
    }
    public String getStrRegexs() {
        String str = "";
        for(Regex regex : regexs) {
            str += regex + "\n";
        }
        return str;
    }
:} 

/* 3. Terminales*/

terminal String RW_CONJ, ID, STRING, CHAR;
terminal String LBRACKET, RBRACKET;
terminal String SEMICOLON, COLON, COMMA, PROMPT, TILDE;
terminal String OR, POSITIVE, KLEENE, CONCAT;
terminal String LIMIT;

/* 4. No Terminales*/
non terminal ini;
non terminal instructions,instruction;
non terminal set, elements;
non terminal specific, regex;
non terminal operations, operation;
non terminal node;
non terminal String character;
non terminal analysis, expression;

/* 5. Precedencias */

/* 6. Gramatica Libre de Contexto */

start with ini;

ini::=LBRACKET instructions LIMIT analysis RBRACKET;

instructions::=
    instruction instructions |
    instruction error |
    instruction;

instruction::=
    set |
    regex;

set::=RW_CONJ COLON ID:id {:initSet(id);:} PROMPT elements SEMICOLON {:addSet();:};

elements::=
    character:start TILDE character:end {:addRange(start,end);:}|
    specific;

specific::=
    character:ch                {:addSpecific(ch);:} |
    specific COMMA character:ch {:addSpecific(ch);:};

character::=
    CHAR:ch         {:RESULT = ch;:} |
    LBRACKET:lb     {:RESULT = lb;:} |
    RBRACKET:rb     {:RESULT = rb;:} |
    SEMICOLON:sm    {:RESULT = sm;:} |
    COLON:cn        {:RESULT = cn;:} |
    COMMA:cm        {:RESULT = cm;:} |
    OR:or           {:RESULT = or;:} |
    POSITIVE:pl     {:RESULT = pl;:} |
    KLEENE:kl       {:RESULT = kl;:} |
    CONCAT:cc       {:RESULT = cc;:};

regex::=ID:id {:initRegex(id);:} PROMPT operations SEMICOLON {:addRegex();:};

operations::=
    operations operation |
    operation;

operation::=
    CONCAT:cc   {:addElement(cc);:} operation operation |
    OR:or       {:addElement(or);:} operation operation |
    KLEENE:kl   {:addElement(kl);:} operation |
    POSITIVE:pl {:addElement(pl);:} operation |
    node;

node::=
    LBRACKET ID:id RBRACKET {:addElement(id);:} |
    STRING:str              {:addElement(str);:};

analysis::=
    expression analysis |
    expression error |
    expression;

expression::=ID COLON STRING SEMICOLON;